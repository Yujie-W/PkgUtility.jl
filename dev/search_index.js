var documenterSearchIndex = {"docs":
[{"location":"#PkgUtility.jl","page":"Home","title":"PkgUtility.jl","text":"A collection of utility functions used for Emerald Land model. The module used to be a sub-module of the under-developing Emerald Land model (not registered), and reusing the functions is more or less inconvenient as one would need to import the entire mega land model to use a very small tool. Therefore, I tease apart the functions that require minimum dependencies and move them to a new package. There are a number of submodules (and utility functions) for different purposes, and they are listed here in an alphabetical order.","category":"section"},{"location":"#ArtifactTools","page":"Home","title":"ArtifactTools","text":"Read and write toml and yaml files to use with GriddingMachine (and other general purposes)","category":"section"},{"location":"#DistributedTools","page":"Home","title":"DistributedTools","text":"Add and remove processors dynamically based on the maximum number of CPU cores and the requested number of threads. For example, if the requested number of threads exceeds the maximum CPU count, the maximum CPU wound be used; if the requested number of threads is fewer than existing workers, the extra ones would be removed.","category":"section"},{"location":"#PrettyDisplay","page":"Home","title":"PrettyDisplay","text":"Display the information within an @info block (or @warn or @error), showing the time of the operation as well","category":"section"},{"location":"#RecursiveTools","page":"Home","title":"RecursiveTools","text":"Test and floating number type or if containing nan within a variable (number, vector, structure, etc) in a recursive manner\n\nCompare and synchronize a structure in a recursive manner","category":"section"},{"location":"#TimeParser","page":"Home","title":"TimeParser","text":"Identify the month index with a known doy-of-year, or the range of doy-of-year of a known month\n\nParse number and string to different formats","category":"section"},{"location":"#PkgUtility.ArtifactTools.read_library","page":"Home","title":"PkgUtility.ArtifactTools.read_library","text":"read_library(filename::String)\n\nRead an Artifact library file in either TOML or YAML format, given\n\nfilename File name of the library file\n\n\n\n\n\n","category":"function"},{"location":"#PkgUtility.ArtifactTools.save_library!","page":"Home","title":"PkgUtility.ArtifactTools.save_library!","text":"save_library!(filename::String, data::Union{Dict, OrderedDict})\nsave_library!(data::Union{Dict, OrderedDict}, filename::String)\n\nSave a Dict as a TOML or YAML file, given\n\nfilename File name of the library file\ndata Data to be saved\n\n\n\n\n\n","category":"function"},{"location":"#PkgUtility.DistributedTools.dynamic_workers!","page":"Home","title":"PkgUtility.DistributedTools.dynamic_workers!","text":"dynamic_workers!(threads::Int; exeflags::String = \"--project\")\n\nAdd processors to run code in multiple threadings, given\n\nthreads Number of threads\nexeflags Flags for the Julia executable\n\n\n\n\n\n","category":"function"},{"location":"#PkgUtility.PrettyDisplay.pretty_display!","page":"Home","title":"PkgUtility.PrettyDisplay.pretty_display!","text":"\n\npretty_display!(msg::String, func_type::String)\n\nDisplay the message based on the message level, given\n\nmsg message to display\nfunc_type message level for displaying\n\nExamples\n\n    pretty_display!(\"This is an entire timed info message\", \"tinfo\");\n    pretty_display!(\"This is the first line of a set of timed info messages\", \"tinfo_pre\");\n    pretty_display!(\"This is the middle line of a set of timed info messages\", \"tinfo_mid\");\n    pretty_display!(\"This is the last line of a set of timed info messages\", \"tinfo_end\");\n\n\n\npretty_display!(pvec::Vector{<:Pair})\n\nDisplay the pairs in a pretty way, given\n\npvec Vector of pairs to display\n\n\n\nExamples\n\n    pvec = [\"A\" => \"b\", \"d\" => \"A\", \"rr\" => [\"ra\" => \"rB\", \"rD\" => \"ra\"]];\n    pretty_display!(pvec);\n\n\n\n\n\n","category":"function"},{"location":"#PkgUtility.RecursiveTools.FT_test","page":"Home","title":"PkgUtility.RecursiveTools.FT_test","text":"FT_test(para::Array, FT)\nFT_test(para::Number, FT)\nFT_test(para::Union{Function, Module, String, Symbol}, FT)\nFT_test(para::Any, FT)\n\nReturn true or false to determine if the FT is consistent, given\n\npara Parameter to run FT control\nFT Float type\n\nIf the testing variable is an array, the function will test if element type is float number:\n\nIf true, the function tests if the element type is the same as given FT\nIf false, the function tests each element recursively\n\nThe variable to test maybe a struct, but FT_test does not know the struct type name a priori. Thus, we try to read out the fields of the variable:\n\nIf succeeds, the function test the fields recursively\nIf fails, then do nothing\n\nExample\n\n    struct SA\n        a\n        b\n    end;\n    sa = SA(1, 2.0);\n\n    ft_1 = FT_test([1, 2, 3], Float64);\n    ft_2 = FT_test(Any[1, 1.0f0, 1.0e0], Float64);\n    ft_3 = FT_test([1, 2.0, \"a\"], Float64);\n    ft_4 = FT_test(sa, Float64);\n\n\n\n\n\n","category":"function"},{"location":"#PkgUtility.RecursiveTools.NaN_test","page":"Home","title":"PkgUtility.RecursiveTools.NaN_test","text":"NaN_test(para::Array)\nNaN_test(para::Number)\nNaN_test(para::Union{Function, Module, String, Symbol})\nNaN_test(para::Any)\n\nTest if the variable is not NaN, given\n\npara Parameter to test\n\nExample\n\n    struct SA\n        a\n        b\n    end;\n\n    nan_1 = NaN_test(SA(1,2));\n    nan_2 = NaN_test(SA(1,NaN));\n    nan_3 = NaN_test([1,2,NaN]);\n    nan_4 = NaN_test([1,3,4]);\n    nan_5 = NaN_test([1,2,\"a\"]);\n\n\n\n\n\n","category":"function"},{"location":"#PkgUtility.RecursiveTools.compare_struct!","page":"Home","title":"PkgUtility.RecursiveTools.compare_struct!","text":"compare_struct!(struct1::ST, struct2::ST; approximation::Bool = true, first_element_array::Bool = true, show_diff_msg::Bool = true) where ST\ncompare_struct!(struct1::ST, struct2::ST, target::Symbol; first_element_array::Bool = true, show_diff_msg::Bool = true) where ST\n\nComparing two structs struct1 and struct2 recursively, given\n\nstruct1 The first struct to compare\nstruct2 The second struct to compare\napproximation Whether to compare the numbers approximately\nfirst_element_array Whether to compare the first element of an array only\nshow_diff_msg Whether to show the difference message\ntarget The field to compare\n\n\n\n\n\n","category":"function"},{"location":"#PkgUtility.RecursiveTools.sync_struct!","page":"Home","title":"PkgUtility.RecursiveTools.sync_struct!","text":"sync_struct!(struct_from, struct_to)\n\nSync the fields from struct_from to struct_to.\n\n\n\n\n\n","category":"function"},{"location":"#PkgUtility.TimeParser.which_month","page":"Home","title":"PkgUtility.TimeParser.which_month","text":"which_month(year::Int, doy::Int)\n\nReturn the month index, given\n\nyear Year\ndoy Day of year (typically 1-365, 1-366 for leap years)\n\n\n\n\n\n","category":"function"},{"location":"#PkgUtility.TimeParser.month_doys","page":"Home","title":"PkgUtility.TimeParser.month_doys","text":"month_doys(year::Int, month::Int)\nmonth_doys(leapyear::Bool, month::Int)\n\nReturn the day of year, given\n\nyear Year\nmonth Month\nleapyear Whether the year is a leap year\n\n\n\n\n\n","category":"function"},{"location":"#PkgUtility.TimeParser.parse_timestamp","page":"Home","title":"PkgUtility.TimeParser.parse_timestamp","text":"parse_timestamp(timestamp::Union{Int,String}, in_format::String, out_format::String)\nparse_timestamp(year::Int, doy::Int, out_format::String)\nparse_timestamp(year::Int, doy::AbstractFloat, out_format::String)\n\nConvert timestamp, given\n\ntimestamp Time stamp\nin_format Format of timestamp, default is YYYYMMDD\nout_format Output format, default is DOY\nyear Year (in this case, the function will convert year and day to timestamp first)\ndoy Day of year (typically 1-365, 1-366 for leap years)\n\nThe input format (string or integer) supports YYYYMMDD, YYYYMMDDhh, YYYYMMDDhhmm, YYYYMMDDhhmmss, and YYYYMMDDhhmmss.mmm, where the labels are\n\nYYYY Year number\nMM Month number\nDD Day number\nhh Hour number\nmm Minute number\nss Second number\nmmm Millisecond number\n\nThe supported outputs are\n\nDATE A Dates.Date type variable\nDATETIME A Dates.DateTime type variable\nDOY A day of year integer\nFDOY A day of year float\n\n\n\nExamples\n\n    time = parse_timestamp(20200130, \"YYYYMMDD\", \"FDOY\");\n    time = parse_timestamp(\"20200130\", \"YYYYMMDD\", \"FDOY\");\n    time = parse_timestamp(2020, 100, \"DOY\");\n    time = parse_timestamp(2020, 100.23435436, \"DATETIME\");\n\n\n\n\n\n","category":"function"}]
}
